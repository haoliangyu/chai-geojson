"use strict";function isPoint$1(t,e,o){t.assert(2===t._obj.coordinates.length,e,o)}function isLineString$1(t,e,o){t.assert(t._obj.coordinates.length>1,e,o),t._obj.coordinates.forEach(function(i){t.assert(Array.isArray(i)&&2===i.length,e,o)})}function isPolygon$1(t,e,o){t.assert(t._obj.coordinates.length>0,e,o),t._obj.coordinates.forEach(function(i){t.assert(Array.isArray(i)&&i.length>1,e,o),i.forEach(function(i){t.assert(Array.isArray(i)&&2===i.length,e,o)})})}function getTypeAssertFunction(t){return typeAssertFunction[t]}function isFeatureCollection(t){t.assert("FeatureCollection"===t._obj.type&&Array.isArray(t._obj.features),"expected #{this} to be a FeatureCollection","expected #{this} to not be a FeatureCollection")}function isFeature(t){t.assert("Feature"===t._obj.type&&"object"===_typeof(t._obj.geometry)&&"object"===_typeof(t._obj.properties),"expected #{this} to be a Feature","expected #{this} to not be a Feature")}function isGeometry(t){var e=t._obj.type,o=getTypeAssertFunction(e);o(t)}function isPoint$$1(t){var e="expected #{this} to be a Point",o="expected #{this} to not be a Point";t.assert("Point"===t._obj.type&&Array.isArray(t._obj.coordinates),e,o),isPoint$1(t,e,o)}function isLineString$$1(t){var e="expected #{this} to be a LineString",o="expected #{this} to not be a LineString";t.assert("LineString"===t._obj.type&&Array.isArray(t._obj.coordinates),e,o),isLineString$1(t,e,o)}function isPolygon$$1(t){var e="expected #{this} to be a Polygon",o="expected #{this} to not be a Polygon";t.assert("Polygon"===t._obj.type&&Array.isArray(t._obj.coordinates),e,o),isPolygon$1(t,e,o)}function isMultiPoint(t){var e="expected #{this} to be a MultiPoint",o="expected #{this} to not be a MultiPoint";t.assert("MultiPoint"===t._obj.type&&Array.isArray(t._obj.coordinates),e,o),isLineString$1(t,e,o)}function isMultiLineString(t){var e="expected #{this} to be a MultiLineString",o="expected #{this} to not be a MultiLineString";t.assert("MultiLineString"===t._obj.type&&Array.isArray(t._obj.coordinates),e,o),isPolygon$1(t,e,o)}function isMultiPolygin(t){var e="expected #{this} to be a MultiPolygon",o="expected #{this} to not be a MultiPolygon";t.assert("MultiPolygon"===t._obj.type&&Array.isArray(t._obj.coordinates),e,o),t._obj.coordinates.forEach(function(i){t.assert(Array.isArray(i)&&i.length>0,e,o),i.forEach(function(i){t.assert(Array.isArray(i)&&i.length>1,e,o),i.forEach(function(i){t.assert(Array.isArray(i)&&2===i.length,e,o)})})})}var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},get=function t(e,o,i){null===e&&(e=Function.prototype);var n=Object.getOwnPropertyDescriptor(e,o);if(void 0===n){var r=Object.getPrototypeOf(e);return null===r?void 0:t(r,o,i)}if("value"in n)return n.value;var s=n.get;if(void 0!==s)return s.call(i)},set=function t(e,o,i,n){var r=Object.getOwnPropertyDescriptor(e,o);if(void 0===r){var s=Object.getPrototypeOf(e);null!==s&&t(s,o,i,n)}else if("value"in r&&r.writable)r.value=i;else{var a=r.set;void 0!==a&&a.call(n,i)}return i},typeAssertFunction={FeatureCollection:isFeatureCollection,Feature:isFeature,Geometry:isGeometry,Point:isPoint$$1,LineString:isLineString$$1,Polygon:isPolygon$$1,MultiPoint:isMultiPoint,MultiLineString:isMultiLineString,MultiPolygon:isMultiPolygin},index=function(t,e){var o=t.Assertion;o.overwriteChainableMethod("a",function(t){return function(i){var n=getTypeAssertFunction(i);if(n){new o(this._obj).to.have.property("type").a("string");var r=new o;e.transferFlags(this,r),n(r)}else t.apply(this,arguments)}},function(t){return function(){t.apply(this,arguments)}})};module.exports=index;